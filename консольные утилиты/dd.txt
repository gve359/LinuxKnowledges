dd - низкоуровнево копирует файл, поблочно преобразуя его. Особенность в том, что в unix "всё есть файл", поэтому dd применяется широко.


СИНТАКСИС
dd [--help] [--version] [if=файл] [of=файл] [ibs=байты] [obs=байты] [bs=байты] [cbs=байты] [skip=блоки] [seek=блоки] [count=блоки] [conv={ascii, ebcdic, ibm, block, unblock, lcase, ucase, swab, noerror, notrunc, sync}]
    
ПРИМЕЧАНИЯ WARNING!
    * В целях безопасности, при копировании устройств, следует их отмонтировать.
    * Не используйте dd для копирования файлов из одной файловой системы в другую, если в этих файловых системах разные размеры блоков.
	* Нельзя применять при LVM и btrfs
    * При использовании dd для копирования файлов на ленту, размер файла должен быть кратным размеру сектора на устройстве (например, 4096 байтов). Для копирования на ленту файлов произвольного размера используйте команды tar(1) или cpio(1).
    * При бэкапах разделов другие советуют ставить bs соответствующий размеру кэша hdd.
    * Q Может ли большое значение bs выйти за пределы копируемого раздела в соседний?
      A Если не использовать копирование напрямую с диска (/dev/sdL), а работать с разделами (/dev/sdLN) или файлами (ранее созданными резервными копиями), и не использовать ненужных опций, типа conv=sync - никакой опасности нет. Чтение просто остановится в конце файла(устройства).
    * Не используйте оба жестких диска («дубликат» и «оригинал») одновременно! При подключении обоих дисков в системе будет по два раздела на каждый UUID, что приведет к проблемам в работе или невозможности загрузки.
    * При получении сигнала SIGINT команда dd перед завершением работы выдаст информацию о состоянии в стандартный поток ошибок. Для остальных сигналов используются стандартные обработчики.
    * При использовании блочного устройства для копирования файлов последний блок будет дополнен нулевыми байтами до границы блока.
    
Флаги:
    ввод/вывод. может и взаимодействовать через stdin/stdout
        if=file - входящий  файл
        of=file - исходящий файл

    bs=bytes - по сколько байт обрабатывать за раз. По умолчанию 512 байт. Устанавливает ibs=obs.
        ibs=bytes - сколько читать
        obs=bytes - сколько писать
  
    count=n - Копирует n ibs-размерных блоков байт из входного файла, а не весь входной файл.
    skip=n  - Пропускает n ibs-размерных блоков байт со входного файла.
    seek=n  - Пропускает n obs-размерных блоков байт в выходном файле.

    cbs=bytes - Задает размер блока для преобразований. Нужно для опций ascii, asciib, unblock, ebcdic, ebcdicb, ibm, ibmb block.
    
    status=LEVEL - вид вывода в stderr                                 
        'none' - подавлять всё, кроме ошибочных сообщений.
        'noxfer' - подавлять финальный перевод статистики.                
        'progress' - периодически показывать перевод статистики.        
        Отправка сигнала USR1 запущеному dd, заставляет его печатать статистику ввода/вывода в stderr.        
    
    conv - типы преобразования. conv=ПРЕОБРАЗОВАНИЕ[,ПРЕОБРАЗОВАНИЕ]... !Вокруг запятых не должно быть пробелов!
    
Типы преобразования:
    noerror - продолжать после ошибок чтения. Пишут что если копировать сбойный диск без этого, то dd будет читать сбойный сектор, пока не протрёт дыру.
    notrunc - не обрезать выходной файл. 
              Если of файл больше чем собираемся записать на его место, то без notrunc просто перепишет. С notrunc, вставит байты в середину файла.
              
              Q Если файл является устройством, то как повлияет на него эта опция? 
              A Анон с quaru исследовал этот вопрос и похоже, что notrunc на устройства не влияет.                            
              Команды типа `dd if=myfile of=/dev/fd0 bs=1k seek=172' завершаются неудачей на некоторых системах, потому что dd пытается обрезать выходной файл, а обрезать блочное устройство нельзя. В таких случаях добавьте флаг `conv=notrunc'.  
    nocreat - не создавать выходящий файл
              
    block   - Для каждой строки во входном файле, выводить cbs байт, заменяя символ новой строки на пробел и добивая пробелами при необходимости. 
    unblock - Заменять заключительные пробелы в каждом входном блоке размера cbs байт на символ новой строки.         
    swab - Менять местами каждую пару входных байт. 
           Если последний байт имеет нечетный порядковый номер, то он просто копируется (так как менять местами нечего).
    sync - Дополнять каждый входной блок до размера ibs путем добавления нулевых байт.
           Когда используется с block или unblock, дополняет пробелами.
  
    ascii  - преобразование EBCDIC в ASCII. 
    ebcdic - преобразование ASCII в EBCDIC. 
    ibm    - преобразование ASCII в альтернативный EBCDIC. 
    
    lcase - Изменять заглавные буквы на строчные. 
    ucase - Изменять строчные  буквы на заглавные. 
  


Принимаемые размеры для N и BYTES:
    b=512, 
    kB=1000, K=1024,  
    MB=1000*1000, M=1024*1024, xM=M,
    GB=1000*1000*1000, G=1024*1024*1024
  
ВОЗВРАЩАЕТ
После завершения работы dd возвращает количество полных или частичных прочитанных и выданных блоков.

  
ПРИМЕРЫ

    Работаем с файлами

        удалить первые 10 байтов стандартного входного потока.
        dd ibs=10 skip=1

        Порезать 10-мегабайтный файл foo на 2 по 5 МБ:
        dd if=foo of=bar.0 bs=1M count=5
        dd if=foo of=bar.1 bs=1M skip=5

        Склеить четыре 100-мегабайтных файла в один:
        dd if=SMILE.001 of=SMILE  bs=1M seek=0
        dd if=SMILE.002 of=SMILE  bs=1M seek=100
        dd if=SMILE.003 of=SMILE  bs=1M seek=200
        dd if=SMILE.004 of=SMILE  bs=1M seek=300

        а можно и так:
        dd if=SMILE.001 > SMILE
        dd if=SMILE.002 >> SMILE
        dd if=SMILE.003 >> SMILE
        dd if=SMILE.004 >> SMILE
    
        Но говорят, проще через cat
        cat SMILE.00{1,2,3,4} >> SMILE
    
    Работа с разделами
    
        Разделы и диски сначала нужно отмонтировать во избежании записи во время бэкапа или путаницы uuid, если копируем диск целиком.
    
        Заполнить всё свободное место в текущем разделе нулями
        dd if=/dev/zero of=zerofill

        Сделать копию главной загрузочной записи (MBR) первого жёсткого диска
        dd if=/dev/hda of=bootloader.mbr bs=512 count=1
    
        Копирует раздел в другой раздел
        dd if=/dev/sda3 of=/dev/sdb3 bs=4096 conv=notrunc,noerror
        
        Создаём резервную копию раздела
        sudo dd if=/mnt/root.dd of=/dev/sdXY bs=1M conv=noerror

        Восстановление из резервной копии
        sudo dd if=/mnt/root.dd of=/dev/sdXY bs=1M conv=noerror
        
        Создает сжатый образ раздела (сначала лучше заполнить свободное пространство нолями)
        dd if=/dev/sdXY bs=1M conv=noerror | gzip -c > /mnt/backup/root.dd.gz

        Восстановление из сжатой резервной копии
        gzip -dc /mnt/root.dd.gz | sudo dd of=/dev/sdXY bs=1M conv=noerror
        
        Создание загрузочного USB-диска (он показан как /dev/sdc)
        dd if=/home/$user/bootimage.img of=/dev/sdc

        Хороший способ проверки диска на испорченные блоки
        dd if=/dev/sda of=/dev/null bs=1m
            
        Восстановление из разрезаной резервной копии
        dd if=/$location/hddimage1.img of=/dev/sda2\   bs=1M
        dd if=/$location/hddimage2.img of=/dev/sda2\   seek=4430 bs=1M
        dd if=/$location/hddimage3.img of=/dev/sda2\   seek=8860 bs=1M
    
        Создание образа диска, сжатого с помощью gzip и разрезанного на части с помощью split.
        dd if=/dev/sda1 | gzip -c | split -b 2000m - /mnt/hdc1/backup.img.gz
	
        Восстановление раздела из созданного выше образа.
        cat /mnt/hdc1/backup.img.gz.* | gzip -dc | dd of=/dev/sda1
                  
    Отладка    

        Разово узнать статус выполнения операции. Выдаст в той консоли, где выполняется dd.
        killall -USR1 dd

        В некоторых случаях статус выполнения просматривается командой:
        pkill -USR1 -x dd

        Так будет выводить отчёт каждые 2 секунды (n2)
        sudo watch -n2 killall -SIGUSR1 dd
    
        В последних версиях статус выполнения можно выводить в консоль, задав команду dd с параметром status=progress
        dd if=image.iso of=/dev/sdb status=progress
