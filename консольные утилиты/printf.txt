printf - форматирует вывод.
Подобна awk-шной. POSIX рекомендует использовать printf, вместо echo.
По умолчанию, не переносит строку в терминале, поэтому нужно смотреть налево от приглашения терминала, либо отформатировать перенос строки самому.
С кириллицей проблемы.



СИНТАКСИС
printf format [argument]…

Представления поступающих аргументов:
N Нормальное десятичное число. Например 177
0N Восьмеричное число. Например 024.
0xN и 0XN Шестнадцатеричные числа. Например 0?41.
"А (обычные кавычки перед любой буквой) Интерпретируется как кодовый номер этой буквы в текущей кодировке. С кириллицей не работает.
'А (одинарные кавычки перед любой буквой) Интерпретируется как кодовый номер этой буквы в текущей кодировке. С кириллицей не работает. 

формат:
Строка формата может быть любой, просто в ней указываются спецификаторы (это перед которыми процент).
"qwe  %s %s  rty\n" 'zxc' 'eee'
qwe  zxc eee  rty

Спецификаторы указывают, в каком типе данных выводить аргументы.
%[модификатор]спецификатор

Спецификаторы:
%c  Символ ASCII; если аргумент является строкой, выводится первый символ строки.
%s  Строка
%b  Строка, с интерпретацией управляющих символов, содержащиеся в ней.
.
%d  Десятичное целое число
%i  Тоже десятичное
%u  Тоже десятичное
.
%f  число с плавающей запятой. В формате [-]ddd.dddddd
%e  число с двойной точностью в формате [-]d.dddddde[+-]dd (с e-шкой, означающей степень)
%E  как %e, но е большая
.
%о	восьмеричное число
%x	шестнадцатеричное число. буквенные цифры в нижнем регистре
%X	шестнадцатеричное число. буквенные цифры в верхнем регистре
.
Не существенные:
%q  Перелопатит каждую букву в спец.символ.
%g  Тип преобразования будет %e или %f в зависимости от того, какой результат короче; вывод незначащих нулей подавляется
$G  Аналогичен спецификатору %g, но экспоненциальный формат будет представлен спецификатором %E, а не %e
%%  Способ экранирования символ '%', интерпретации аргумента не происходит

Модификаторы дополнительно форматируют спецификаторы
%[[-]lengthFiled[.precision]]s
%[+][[-][0]lengthFiled]d
%[+][[-][0]lengthFiled[.precision]]f

Модификаторы:
-            Выравание на лево (по умолчанию выравнивание на право)
пробел       Работает и вплотную.
             Если аргумент является положительным числом, перед ним ставится пробел, а если отрицательным — знак минус.
+            Положительным числам и 0 спереди ставится +. У отрицательных - не отбирается.
0            Если длина поля больше, чем количество цифр в числе, то число дополняется нулями, а не пробелами.
lengthFiled  Число, обозначающее длину поля. Если значение меньше длины, оно дополниться пробелами. Если больше, то пишется во всю настоящую длину.
precision    Точность. 
             Для дробных, обозначает длину хвоста. Входит в состав lengthFiled
			 Для строк, обезает что не уместилось в это значение
#            Альтернативная форма спецификатора:
             %о — восьмеричному числу предшествует ведущий ноль;
             %x — шестнадцатеричному числу предшествует запись 0x;
             %X — шестнадцатеричному числу предшествует запись 0x;
             %e, %E, %f — число всегда содержит десятичную точку;
             %g, %G — вывод незначащих нулей не подавляется

Cимволы форматирования вывода:
\а	звуковой сигнал
\b	удаление предшествующего символа
\c  Не производить дальнейшую обработку данных
\r	возврат каретки
\f	прокрутка страницы
\n	новая строка
\t	табуляция
\v  вертикальная табуляция
\" Двойные кавычки
\NNN Символ с восьмеричным значением NNN (от 1 до 3 цифр)
\\ Обратный слэш (\)
\xHH Символ с шестнадцатеричным кодом HH (1 или 2 цифры)
\uHHHH Символ Unicode (ISO/IEC 10646) с шестнадцатеричным кодом HHHH (4 цифры)
\UHHHHHHHH Символ Unicode с шестнадцатеричным кодом HHHHHHHH (8 цифр)
%% Символ % 





ПРИМЕРЫ

эквивалент echo
printf '%b\n' 'Это заклинание заменит команду echo'

вывод юникод символа
printf '\u25b2\n'
▲

преобразует 16ричное число 2В в соответствующее 10чное значение ASCII,'+'. 
$ printf "\x2B\n"  
+

Вывести шестнадцатеричное число в десятичной форме:
$ printf '%d\n' '-0x41'
-65

Вывести десятичное число в восьмеричной форме:
$ printf '%o\n' 65
101

Узнать кодовый номер буквы А (англ):
$ printf '%d\n' \'A
65

выводит на печать строку, выровненную по левому краю, начиная с 10–го символа от левого края.
$ printf "%-10sStand-by\n"
	Stand-by

Узнать, какой ASCII–символ зашифрован под кодом 65
$ echo "65" | awk '{printf "%c\n", $0}'
A

Демонстрация %b
$ printf "%s\n" "1" "2" "\n3"
1
2
\n3
$ printf "%b\n" "1" "2" "\n3"
1
2

3


Как выровнять по центру: (не проверял)
Чувак хочет вот так: 
$printf 'ddd %-22s dddd \n' "eeeeeee"
ddd      eeeeeee      dddd
решение 1 
STR="eeeeeee"; printf 'ddd %11s%-11s dddd \n' `echo $STR | cut -c 1-$((${#STR}/2))` `echo $STR | cut -c $((${#STR}/2+1))-${#STR}`
решение 2
D="12"    # input string
BS=10     # buffer size
L=$(((BS-${#D})/2))
[ $L -lt 0 ] && L=0
printf "start %${L}s%s%${L}s end\n" "" $D ""
решение 3
title="Your title goes here"
printf "%*s\n" $(((${#title}+$COLUMNS)/2)) "$title"
решение 4
int len = strlen(s);
int ww = (mm - len) / 2 + len; /* это же (mm + len) / 2; */
printf('%*s\n', ww, s);
решение 5
Ruby:
"xxx".center(9) ==>"   xxx   "
Awk:
BEGIN {
  print ">" center( "xxx", 9 ) "<"
}
function center( str, n    ,left,right )
{ right = int((n - length(str)) / 2)
  left = n - length(str) - right
  return sprintf( "%" left "s%s%" right "s", "", str, "" )
}