find - поиск файлов

find это не то чтобы поиск, это скорее select, или цикл. Может тут-же обрабатывать каждый найденый файл.
Пути выводятся все, но по неизвестному порядку. Их нужно либо сортировать отдельно, либо если по иерархии, то тут решение есть.
По умолчанию выводит полные пути.


КЛЮЧИ
-name          Поиск файлов, по имени (регулярака)
-perm          Поиск файлов, по режиму доступа. Вроде только цифрами.
-user          Поиск файлов, по пользователю
-group         Поиск файлов, по группе
-nogroup       Поиск файлов, для которых, отсутствует запись в файле /etc/groups
-nouser        Поиск файлов, для которых, отсутствует запись в файле /etc/passwd
-type          Поиск файлов определенного типа, а именно:
               b — cпециальный блочный файл;
               d — каталог;
               с — cпециальный символьный файл;
               p — именованный канал;
               l — cимволическая ссылка;
               s — cокет;
               f — oбычный файл
-size n        Поиск файлов, по размеру. Размер n единиц. Виды единиц:
               b — блок размером 512 байтов (установка по умолчанию);
               c — байт;
               k — килобайт (1024 байта);
               w — двухбайтовое слово
               имеются префиксы +-, означающие больше/меньше. Например: find . -size +1M найдёт файлы весящие > 1мб
-mtime -n +n   Поиск файлов, содержимое которых модифицировалось менее чем (-) или более чем (+) n дней назад; имеются также опции -atime и -ctime, которые позволяют осуществлять поиск файлов соответственно по дате последнего чтения и дате последнего изменения атрибутов файла
-iname         регистро нечувствительный поиск
-newer файл    Поиск файлов, которые созданы позднее, чем указанный файл
-P             Никогда не открывать символические ссылки
-L             Получает информацию о файлах по символическим ссылкам. Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.
-depth         Сначала просматривается содержимое текущего каталога а затем сам каталог. Это как-то применяется при бэкапах cpio и tar.
               Это не способ обхода графа в ширину. Последним выводится лишь рассматриваемый каталог.
-maxdepth      Уровень рекурсии. 1 для поиска каталоге, не заходя в подкаталоги.
? -prune       Не выполнять рекурсивный поиск по уже найденному пути; при -depth, -prune игнорируется.
? -fstype      Поиск файлов, которые находятся в файловой системе определенного типа; обычно соответствующие сведения хранятся в файле /etc/fstab, который содержит данные о файловых системах, используемых на локальном компьютере
-mount         Поиск файлов только в текущей файловой системе, не заходя в примонтированные; аналогом этой опции является опция -xdev
-exec          Вызов команды для найденых файлов. Если пути слишком длинные или с пробелами, то нужен xargs. Вместо скобок подставляется путь. Скобки и точкасзапятой должны быть экранированы от шелла.
               Экзеков может быть несколько.
					find path -exec команда '{}' \; - для каждого файла будет выполнена команда
					    xargs эквивалент find $path -print0 | xargs -0 ./echoSleep.sh
					find path -exec команда '{}' \+ - файлы станут параметрами одной команды
					    xargs эквивалент xargs эквивалент find $path -print0 | xargs -0 -n 1 ./echoSleep.sh
					Второй экзек выполнится, если первый завершился успешно.
					find . -name "*.txt" -exec echo {} \; -exec grep banana {} \;
					Независимые обработки exec
					find . -name "*.txt" \( -exec echo {} \; -o -exec true \; \) -exec grep banana {} \;
			   скрипт в exec
					find . -exec sh -c "echo -n {}; echo -n ' x '; echo {}" \;
					find . -exec sh -c 'echo $(basename "{}")' \;
-execdir       В отличии от exec, пишется не полный путь, а относительно стартового.
-ok            Аналогична -exec, но перед выполнением команды спрашивает
-print         Запись полных имен найденных файлов в стандартный поток вывода
	           Позволяет выдавать на выходной поток не по одному результату а все скопом. Что нужно для следующей по конвейеру команде.
-print0        Как print, но выдаёт единую строку(это чувствуется, когда в пути есть пробел, и он должен быть обработан следующей командой)
-printf        Настраиваемый формат вывода. Можно вывести всё, что есть в ls. Частично совпадает с printf нормальной, но спецификаторов там нет, хотя модификаторы есть.
-a             Логическое and. Например, поиск файлов включая начинающихся и с точки и с цифры find ~ -name ".*" -o -name "[0-9]*"
-o             Логическое or
!              Отрицание. Например, выведем все не каталоги find . ! -type d -print
? -path        Недопонял, но это в сочитании с отрицанием, помогает исключить каталог из выдачи find Help/../settings ! -path Help/../settings | less


ПРИМЕРЫ

Простой поиск
find . -name "*чать имени файла*.txt"

Отображение, подобное ls
find -H ~ -printf '%y;%M;%n;%u;%g;%s;%t;%p\n'
find -H ~ -printf '%y%M;%n;%u;%g;%s;%TY%Tm%Td-%TH%TM%TS;%p\n' то-же, но с форматированной дата-временем

подсчитать количество папок
find path -type d | wc -l

Пример, в котором команда grep ищет файлы, содержащие слово "device":
$ find / -type f -print | xargs grep "device"

Связка с xargs, если -exec не срабатывает
find $path -print0 | xargs -0 ls -ld

Цикл и find
for i in $(find $path -print0)
do
	ls -la "$i"
done

Иерерхический вид. По сути первый find ходит по папкам, и в exec ему вставляем find по уровню
Вывести объекты ФС
find -P $path -type d -print -exec find "{}" -maxdepth 1 ! -type d \;
Расписать информацию о структуре ФС
find -P $path -type d -printf '%y %p/\n' -exec find "{}" -maxdepth 1 ! -type d -printf '%y %p\n' \;
Обработать всё. Дольше по времени.
find -P $path -type d -exec find "{}" -maxdepth 0 -printf '%y %p/\n' \; -exec find "{}" -maxdepth 1 ! -type d -printf '%y %p\n' \;




#взвесить каждый файл
#! думаю, что du не нужно пользоваться. Теперь я нашёл, что ls -l | awk $5 для веса. Возможно, именно du лез куда не просят.
#find path -type f | xargs du -b    # однако, с xargs оно может выбраться за проеделы папки. Почему - пока не ясно.
#find path -type f -print0 | xargs -0 du -b   #Если путь содержит пробелы, то поможет этот вариант. (xargs всё распихает по параметрам)



НЕ ЯСНОСТИ
как работают трубы с циклом? выдают всё по мере поступления, или ждут, пока прога завершится и накопятся выводы?

пример, где xargs и exec(в качестве побочного действия) всесте. Он демонстрирует, что xargs -0 -n 1 дают построчную а не групповую обработку
find / -exec echo FIND \;  -print0 | xargs -0 -n 1 /home/newfag/Yandex.Disk/work/linux/programs/echoSleep.sh

странно, без -n 1 выдаёт текст пучками, но и FIND пишет. Всё ли нормально?
find / -exec echo FIND \;  -print0 | xargs -0 /home/newfag/Yandex.Disk/work/linux/programs/echoSleep.sh
